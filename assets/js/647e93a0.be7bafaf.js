"use strict";(self.webpackChunkvex_docs=self.webpackChunkvex_docs||[]).push([[3286],{4141:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"exchange-design/backend-architecture/Order_Routing_System","title":"Order Routing System","description":"The Order Routing System is responsible for directing validated orders from the OMS to the appropriate Matching Engine. It ensures that each order reaches the correct destination based on the trading pair (e.g., BTC/USDC, ETH/USDC).","source":"@site/docs/exchange-design/backend-architecture/07_Order_Routing_System.md","sourceDirName":"exchange-design/backend-architecture","slug":"/exchange-design/backend-architecture/Order_Routing_System","permalink":"/exchange-design/backend-architecture/Order_Routing_System","draft":false,"unlisted":false,"editUrl":"https://github.com/trade-vex/vex-docs/edit/main/docs/exchange-design/backend-architecture/07_Order_Routing_System.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"Order_Routing_System","title":"Order Routing System","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Order Flow Lifecycle","permalink":"/exchange-design/backend-architecture/Order_Flow_Lifecycle"},"next":{"title":"Matching Engines","permalink":"/exchange-design/backend-architecture/Matching_Engines"}}');var i=n(4848),s=n(8453);const o={id:"Order_Routing_System",title:"Order Routing System",sidebar_position:7},a="Order Routing System",c={},d=[{value:"Key Points",id:"key-points",level:2}];function h(e){const t={blockquote:"blockquote",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"order-routing-system",children:"Order Routing System"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"Order Routing System"})," is responsible for directing validated orders from the OMS to the appropriate Matching Engine. It ensures that each order reaches the correct destination based on the trading pair (e.g., BTC/USDC, ETH/USDC)."]}),"\n",(0,i.jsxs)(t.p,{children:["This component is designed for ultra-low latency and uses ",(0,i.jsx)(t.strong,{children:"UDP"})," to transmit orders efficiently. Since matching engines are isolated per trading pair and often run on separate machines, UDP helps avoid the overhead of traditional transport protocols."]}),"\n",(0,i.jsx)(t.h2,{id:"key-points",children:"Key Points"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Uses ",(0,i.jsx)(t.strong,{children:"symbol-based routing"})," to determine the target Matching Engine."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"UDP transport"})," is used for speed and simplicity in one-way communication."]}),"\n",(0,i.jsx)(t.li,{children:"Designed to be stateless, allowing horizontal scaling and easy failover."}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"This system acts as a lightweight and fast bridge between the core logic of the exchange and its execution layer."})}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(6540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);